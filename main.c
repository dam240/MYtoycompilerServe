#include <stdio.h>
#include <stdlib.h>
#include <elf.h>
#include <sys/stat.h>

#define START_ADDRESS    (0x01000000 + PROG_START)
#define PROG_START   (0x100)

void out_elf_header(FILE *fp, uintptr_t entry, int phnum, int shnum) {
  Elf64_Ehdr ehdr = {
    .e_ident     = { ELFMAG0, ELFMAG1, ELFMAG2 ,ELFMAG3,
                     ELFCLASS64, ELFDATA2LSB, EV_CURRENT, ELFOSABI_SYSV },
    .e_type      = phnum > 0 ? ET_EXEC : ET_REL,
    .e_machine   = EM_X86_64,
    .e_version   = EV_CURRENT,
    .e_entry     = entry,
    .e_phoff     = phnum > 0 ? sizeof(Elf64_Ehdr) : 0,
    .e_shoff     = 0, // dummy
    .e_flags     = 0x0,
    .e_ehsize    = sizeof(Elf64_Ehdr),
    .e_phentsize = phnum > 0 ? sizeof(Elf64_Phdr) : 0,
    .e_phnum     = phnum,
#if !defined(__NO_ELF_OBJ)
    .e_shentsize = shnum > 0 ? sizeof(Elf64_Shdr) : 0,
#else
    .e_shentsize = 0,
#endif  // !defined(__NO_ELF_OBJ)
    .e_shnum     = shnum,
    .e_shstrndx  = shnum > 0 ? shnum - 1 : 0,
  };
//  printf("shnum=%d entry =%ld\n",shnum,entry);
  fwrite(&ehdr, sizeof(Elf64_Ehdr), 1, fp);
}

void out_program_header(FILE *fp, int sec, uintptr_t offset, uintptr_t vaddr, size_t filesz,
                        size_t memsz) {
  static const int kFlags[] = {
    PF_R | PF_X,  // code
    PF_R | PF_W,  // rwdata
  };
  printf("out_program_header-------------------%ld,--------%ld,%ld,--------%ld\n",offset,vaddr,filesz,memsz);
  Elf64_Phdr phdr = {
    .p_type   = PT_LOAD,
    .p_offset = offset,//固定地址 //PROG_START代码的地方 头文件信息如果大于PROG_START就不会有填充0
    .p_vaddr  = vaddr, //起START_ADDRESS
    .p_paddr  = 0, // dummy
    .p_filesz = filesz,//代码加常量一共多少字节
    .p_memsz  = memsz,//代码加常量一共多少字节
    .p_flags  = kFlags[sec],
    .p_align  = 0x10,
  };




  fwrite(&phdr, sizeof(Elf64_Phdr), 1, fp);
}




static void put_padding(FILE *fp, uintptr_t  start) {
	printf("put_padding----------------\n");
  long cur =ftell(fp);
  printf("cur=== %ld  ",cur);
  if (start > (size_t)cur) {
    size_t size = start-(uintptr_t)cur;
    char *buf = calloc(1, size);
	printf("%s %ld ",buf,size);
    fwrite(buf, size, 1, fp);
	//IntToChars(size,buf);
    free(buf);
  }
  	printf("--------\n");
}

int main(){


int  func[10];

 FILE *fp;
 char name[]="hello";

    fp = fopen(name, "wb");
    if (fp == NULL) {
      printf( "Failed to open output file: \n");
      return 1;
    }


char code[]={0x48,0x8b,0x3c,0x24, 0x48,0x8d,0x74,0x24,0x8,0xe8,0x7f,0x1,0,0,0x89,0xc7,0xeb,0x1,0xc3,0xb8,0x3c,0,0,0,0xf,0x5,0xc3,0xb8,0x1,0,0,0,0xf,0x5,0xc3,0x55,0x48,  0x89,0xe5, 0x48,0x83,0xec,0x8,0x48,0x89,0x7d,0xf8,0x53,0x4c,0x8b,0x7d,0xf8,0x4c,0x89,0xfb,0x44,0x8a,0x13,0x45,0x84,0xd2,0x74,0xc,0x49,0x89,0xda,0x49,0x83,0xc2,0x1,0x4c,  0x89,0xd3,0xeb,0xec,0x4c,0x8b,0x7d,0xf8,0x4c,0x29,0xfb,0x48,0x89,0xd8,0x5b,0x48,0x89,0xec,0x5d,0xc3,0x55,0x48,0x89,0xe5,0x48,0x83,0xec,0x8,0x48,0x89,0x7d,0xf8,0x53,0x4c,  0x8b,0x7d,0xf8,0x41,0x57,0x5f,0xe8,0xaf,0xff,0xff,0xff,0x48,0x89,0xc3,0x53,0x4c,0x8b,0x7d,0xf8,0x41,0x57,0x6a,0x1,0x5f,0x5e,0x5a,0xe8,0x93,0xff,0xff,0xff,0x48,0x89,0xc3,  0x5b,0x48,0x89,0xec,0x5d,0xc3,0x55,0x48,0x89,0xe5,0x48,0x83,0xec,0x18,0x48,0x89,0x7d,0xf8,0x53,0x41,0x54,0x48,0x8d,0x5d,0xe8,0x48,0x83,0xc3,0x10,0x41,0xba,0,0,0,0,0x4c,  0x8b,0x7d,0xf8,0x49,0x83,0xff,0,0x7d,0x17,0x4c,0x8b,0x7d,0xf8,0x4d,0x89,0xfb,0x49,0xf7,0xdb,0x4d,0x89,0xdf,0x4c,0x89,0x7d,0xf8,0x41,0xba,0x1,0,0,0,0x4c,0x8b,0x7d,0xf8,  0x4d,0x89,0xfb,0x4c,0x89,0xd8,0x49,0xc7,0xc7,0xa,0,0,0,0x48,0x99,0x49,0xf7,0xff,0x49,0x89,0xd3,0x49,0x83,0xc3,0x30,0x49,0x89,0xdc,0x49,0x83,0xec,0x1,0x4c,0x89,0xe3,0x45,  0x88,0x1c,0x24,0x4c,0x8b,0x7d,0xf8,0x4d,0x89,0xfb,0x4c,0x89,0xd8,0x49,0xc7,0xc7,0xa,0,0,0,0x48,0x99,0x49,0xf7,0xff,0x49,0x89,0xc3,0x4d,0x89,0xdf,0x4c,0x89,0x7d,0xf8,0x4c, 0x8b,0x7d,0xf8,0x4d,0x85,0xff,0x75,0xac,0x45,0x85,0xd2,0x74,0x10,0x49,0x89,0xda,0x49,0x83,0xea,0x1,0x4c,0x89,0xd3,0x41,0xb3,0x2d,0x45,0x88,0x1a,0x48,0x83,0xec,0x8,0x4c, 0x8d,0x55,0xe8,0x49,0x83,0xc2,0x10,0x49,0x29,0xda,0x41,0x52,0x53,0x6a,0x1,0x5f,0x5e,0x5a,0xe8,0xc7,0xfe,0xff,0xff,0x48,0x83,0xc4,0x8,0x48,0x89,0xc3,0x41,0x5c,0x5b,0x48,  0x89,0xec,0x5d,0xc3,0x55,0x48,0x89,0xe5,0x53,0x48,0x83,0xec,0x8,0x6a,0xe,0x48,0x8d,0x1d,0x47,0,0,0,0x53,0x6a,0x1,0x5f,0x5e,0x5a,0xe8,0x9b,0xfe,0xff,0xff,0x48,0x83,0xc4,  0x8,0x48,0x89,0xc3,0x5b,0x48,0x89,0xec,0x5d,0xc3,0x55,0x48,0x89,0xe5,0x53,0x48,0x83,0xec,0x8,0x6a,0x8,0x48,0x8d,0x1d,0x1f,0,0,0,0x53,0x6a,0x1,0x5f,0x5e,0x5a,0xe8,0x71,  0xfe,0xff,0xff,0x48,0x83,0xc4,0x8,0x48,0x89,0xc3,0xb8,0,0, 0,0,0x5b,0x48,0x89,0xec,0x5d,0xc3};//代码区

char date[]={0x31 , 0 , 0x31 , 0x35 , 0x35,  0x35 , 0x35 ,0x0A,0 };//常量区

char haed[]={0x55,0x48,0x89,0xe5,0x48,0x83,0xec,0x30,  //对应==test (){ char d[]="111"; printf("%s \n",d);  }
0xc6,0x45,0xa0, 0x31,
0xc6,0x45,0xa1,0x31,
0xc6,0x45,0xa2,0x31,
0xc6,0x45,0xa3,0x0a,
0x48,0xc7,0xc0,0x01,0x00,0x00,0x00, 
0x48, 0xc7,0xc7,0x01,0x00,0x00,0x00, 
0x48, 0x8d, 0x4d,0xa0,
0x48, 0x89,0xce,
0x48, 0xc7,0xc2,0x0d,0x00,0x00,0x00, 
0x0f,0x05,
 0xc9,
0xc3,
};


int rdates=sizeof(code)+sizeof(date); //总共字节数
//uintptr_t addrt=START_ADDRESS+haed[0];

out_elf_header(fp,START_ADDRESS,2,0); //设置开始位置

out_program_header(fp, 0, PROG_START, START_ADDRESS, rdates, rdates);
//printf("%ld  \n ",addrt);
put_padding(fp,PROG_START);

fwrite(code, sizeof(code), 1, fp);
fwrite(date, sizeof(date), 1, fp);

 fclose(fp);

  if (chmod(name, 0755) == -1) {
    perror("chmod failed\n");
    return 1;
  }


return 0;
}